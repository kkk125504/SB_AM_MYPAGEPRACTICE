### 댓글 작성 기능 구현

- 댓글도 마찬가지로 ReplyController, ReplyService, ReplyRepository 먼저 만들고 기능을 추가

**1\) ReplyController**

```java
@RequestMapping("/usr/reply/doWrite")
	@ResponseBody
	public String doWrite(String relTypeCode, int relId, String body, String replaceUri) {

		if (Ut.empty(relTypeCode)) {
			return rq.jsHistoryBack("relTypeCode을(를) 입력해주세요");
		}

		if (Ut.empty(relId)) {
			return rq.jsHistoryBack("relId을(를) 입력해주세요");
		}

		if (Ut.empty(body)) {
			return rq.jsHistoryBack("body을(를) 입력해주세요");
		}
		ResultData writeReplyRd = replyService.writeReply(rq.getLoginedMemberId(),relTypeCode,relId,body);

		if (Ut.empty(replaceUri)) {
			switch (relTypeCode) {
			case "article":
				replaceUri = Ut.f("../article/detail?id=%d", relId);
				break;
			}
		}

		return rq.jsReplace(writeReplyRd.getMsg(), replaceUri);
```

- ```댓글 작성 폼```으로 댓글을 작성을 시도한다면 ```onsubmit="ReplyWrite__submitForm(this); return false;``` 속성을 통해 빈 내용 시 제출 하지 않는다.
- relTypeCode와 relId 또한 폼태그안에서 전달하고 있으므로 문제가 없으나
- ```uri로 요청시``` relTypeCode,relId ,body에 대한 데이터가 없다면 뒤로돌아가게 구현
- replyService를 통해 댓글이 작성됬다면 해당 게시물 상세페이지로 replace

**2\) ReplyService**

```java
public ResultData writeReply(int actorId, String relTypeCode, int relId, String body) {
		
		replyRepository.writeReply(actorId,relTypeCode, relId, body);
		
		int id = replyRepository.getLastInsertId();
		
		return ResultData.from("S-1", Ut.f("%d번 댓글이 등록되었습니다", id), "id", id);
	}
```

- replyRepository를 통해 DB에 댓글테이블에 댓글을 추가하고
- 마지막으로 추가된 댓글의 아이디과 함께 ResultData로 댓글 작성 결과를 반환한다.

**3\) ReplyRepository**

```java
@Insert("""
			<script>
			INSERT INTO reply
			SET regDate = NOW(),
			updateDate = NOW(),
			memberId = #{actorId},
			relTypeCode = #{relTypeCode},
			relId = #{relId},
			`body` = #{body}
			</script>
			""")
	void writeReply(int actorId, String relTypeCode, int relId, String body);
	
	@Select("""
			<script>
			SELECT LAST_INSERT_ID()
			</script>
			""")
	int getLastInsertId();
```

- DB에 댓글테이블에 데이터를 추가하는 쿼리문과 추가된 로우의 마지막 아이디 구하는 쿼리문

  