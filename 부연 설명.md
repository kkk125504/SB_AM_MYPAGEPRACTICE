 ### 댓글 수정 폼 구현 (중복 발송 x, 빈 내용 발송 x)

**1\) ReplyController**

```java
	@RequestMapping("/usr/reply/modify")
	public String modify(Model model, int id, String replaceUri) {
		if (Ut.empty(id)) {
			return rq.jsHistoryBackOnView("id가 없습니다");
		}
		Reply reply = replyService.getForPrintReply(rq.getLoginedMember(),id);
		
		if (reply == null) {
			return rq.jsHistoryBackOnView(Ut.f("%d번 댓글은 존재하지 않습니다", id));
		}
		
		if (reply.isExtra__actorCanModify() == false) {
			return rq.jsHistoryBack("해당 댓글을 수정할 권한이 없습니다");
		}
		
		String relDataTitle = null;

		switch (reply.getRelTypeCode()) {
		case "article":
			Article article = articleService.getArticle(reply.getRelId());
			relDataTitle = article.getTitle();
			break;
		}
		model.addAttribute("reply", reply);
		model.addAttribute("relDataTitle", relDataTitle);
		
		return "usr/reply/modify";
	}
```

- uri로 접근시 댓글의 존재 여부, 권한을 체크

- 댓글 수정 페이지에 댓글과, 게시물의 제목(```relDataTitle```)을 넘겨준다. modify.jsp에서 보여주기 위해
- 이때 댓글의 관련데이터(```reply.getRelTypeCode()```) 가 article이므로 
- articleService로부터 게시물 데이터를 가져와 게시물의 제목만 model객체에 추가

**2\) modify.jsp**

```java
	<script>
		var ReplyModify__submitDone = false;
		
		function ReplyModify__submitForm(form){
			if(ReplyModify__submitDone){
				alert('이미 처리중 입니다.');
				return;
			}
			form.body.value = form.body.value.trim();
			if(form.body.value.length==0){
				alert('댓글을 작성 해주세요.');
				form.body.focus();
				return;
			}
			ReplyModify__submitDone = true;
			form.submit();		
		}	
	</script>
```

- 테이블로 댓글 수정 폼에서 전송시 빈내용, 중복발송 처리를 방지

  