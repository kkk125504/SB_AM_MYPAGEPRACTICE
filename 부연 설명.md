### modify form을 보여주기 전에 체크, modify form 제작, url로 수정하려는 시도 방어, 수정 후에 replace

**1\)  수정 시도시 수정페이지를 보여주기 이전에 체크**

```java
    @RequestMapping("/usr/article/modify")
	public String showModify(HttpServletRequest req, Model model, int id) {
		Rq rq = (Rq) req.getAttribute("rq");

		Article article = articleService.getForPrintArticle(rq.getLoginedMemberId(), id);
		model.addAttribute("article", article);
		
		if (article == null) {
			return rq.jsHistoryBackOnView(Ut.f("%d번 게시물은 존재하지 않습니다.", id));
		}
		ResultData actorCanModifyRd = articleService.actorCanModify(rq.getLoginedMemberId(), article);
		
		if (actorCanModifyRd.isFail()) {
			return rq.jsHistoryBackOnView(actorCanModifyRd.getMsg());
		}

		return "usr/article/modify";
	}
```

- 수정페이지를 ```보여주기 전```에 게시물 존재여부, 권한 체크하여 ```수정페이지로 이동 제한```
- ```@ResponseBody```어노테이션이 없기때문에
- ```rq.jsHistoryBackOnView()```의 메소드는  ```jsp파일위치``` 를 반환 해야한다. 
- 게시물 존재하지 않을시, 권한이 없다면 ```반환된 jsp파일위치```로 이동
- 게시물이 존재하고 권한이 있을시 ```modify.jsp```파일을 보여주게 됨

**2\) rq.jsHistoryBackOnView**

```java
   		public String jsHistoryBackOnView(String msg) {
		req.setAttribute("msg", msg);
		req.setAttribute("historyBack", true);
		return "usr/common/js";
	}
```

- 게시물 존재하지 않을시 , 수정 권한이 없을시 이동해야할 ```jsp파일의 위치를 반환하는 메소드```
- rq객체 에는 HttpSevletRequest객체를 가지고 있다.
- ```"usr/common/js"``` 로 이동전에 setAttribute를 통해 ```msg```와 ```historyBack```을 request객체에 담는다.

**3\) usr/common/js.jsp**

```jsp
	<script>
        var historyBack = '${historyBack}' == 'true';
        var msg = '${msg}'.trim();
        if (msg) {
            alert(msg);
        }
        if (historyBack) {
            history.back();
        }
        var replaceUri = '${replaceUri}'.trim();
        if (replaceUri) {
            location.replace(replaceUri);
        }
	</script>
```

- 수정페이지로 ```이동 실패```시 보여주게 되는 jsp파일
- 자바스크립트에서도 ```EL표현식```을 사용할수 있다.
- request객체로부터 담겨져있는 ```msg```와 ``` historyBack```을 통해 ```페이지 뒤로가기```와 ```메세지경고창``` 을 구현

**4\) url로 수정하려는 시도 방어, 수정 후에 replace**

```java
	@RequestMapping("/usr/article/doModify")
	@ResponseBody
	public String doModify(HttpServletRequest req, int id, String title, String body) {
		Rq rq = (Rq) req.getAttribute("rq");

		Article article = articleService.getForPrintArticle(rq.getLoginedMemberId(), id);

		if (article == null) {
			return Ut.jsHistoryBack(Ut.f("%d번 게시물은 존재하지 않습니다.", id));
		}
		
		ResultData actorCanModifyRd = articleService.actorCanModify(rq.getLoginedMemberId(), article);
		if (actorCanModifyRd.isFail()) {
			return Ut.jsHistoryBack(actorCanModifyRd.getMsg());					
		}
		
		articleService.modifyArticle(id, title, body);
		return Ut.jsReplace(Ut.f("%d번 게시물 수정", id), Ut.f("../article/detail?id=%d", id));
	}
```

- 권한체크를 통과하고 수정 페이지(```/usr/article/modify```)에서  ```/usr/article/doModify```로 이동하는 정상적인 루트 문제가 없지만
- /usr/article/doModify  ```url```로 ```직접 수정시도시``` 수정권한체크를 하여 수정시도를 ```방어```해야한다.
